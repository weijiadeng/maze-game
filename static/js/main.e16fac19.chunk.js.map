{"version":3,"sources":["Labyrinth/Controls.jsx","Utils/Utils.js","Labyrinth/Walls.jsx","Labyrinth/Labyrinth.jsx","App.js","index.js"],"names":["extend","TrackballControls","Controls","props","ref","controls","React","useThree","camera","gl","targetX","setTargetX","targetZ","setTargetZ","targetDirection","setDirection","currentAngle","setCurrentAngle","moveForward","posCoordX","posCoordY","direction","turnLeft","turnRight","useFrame","position","z","lookAt","x","console","log","updateProjectionMatrix","rotateY","THREE","degToRad","args","domElement","dynamicDampingFactor","UnionFind","elementNum","this","partsCount","path","Array","apply","length","map","Number","call","rank","index","left","right","leftRoot","find","rightRoot","getWallNeighbourCells","numX","numCells","wallIndex","initLabyrinthWalls","numY","unionFind","wallArray","resArray","i","push","currentPos","targetArray","j","Math","floor","random","tmp","shuffleArray","currentWall","neighborA","neighborB","union","wallLeft","fill","wallTop","GenHorizontalWall","width","height","depth","rotation","attach","color","GenVerticalWall","PI","GenWalls","blockWidth","blockHeight","blockDepth","mazeWidth","mazeDepth","walls","Labyrinth","numZ","currentPosX","setPosX","currentPosZ","setPosZ","controlsRef","startCoordX","startCoordY","newX","newZ","current","val","newPosCoordY","fov","intensity","skyColor","groundColor","App","visRef","className","onClick","rootElement","document","getElementById","ReactDOM","render"],"mappings":"oMAMAA,YAAO,CAAEC,wBAET,IAAMC,EAAW,SAACC,EAAOC,GACvB,IAAMC,EAAWC,WADc,EAERC,cAAfC,EAFuB,EAEvBA,OAAQC,EAFe,EAEfA,GAFe,EAKDH,WAAe,KALd,mBAKxBI,EALwB,KAKfC,EALe,OAMDL,WAAe,KANd,mBAMxBM,EANwB,KAMfC,EANe,OAOSP,WAAe,GAPxB,mBAOxBQ,EAPwB,KAOPC,EAPO,OASST,WAAe,GATxB,mBASxBU,EATwB,KASVC,EATU,KA2E/B,OAhEAX,sBAA0BF,GAAK,iBAAO,CACpCc,YAAa,SAACC,EAAWC,EAAWC,GAClCV,EAAWQ,GACXN,EAAWO,GACXL,EAAaM,IAGfC,SAAU,SAACH,EAAWC,EAAWC,GAC/BV,EAAWQ,GACXN,EAAWO,GACXL,EAAaM,GACbJ,EAAgB,GAAKD,IAEvBO,UAAW,SAACJ,EAAWC,EAAWC,GAChCV,EAAWQ,GACXN,EAAWO,GACXL,EAAaM,GACbJ,EAAgBD,EAAe,SAInCQ,aAAS,WAGP,OAAQV,GACN,KAAK,EACCN,EAAOiB,SAASC,EAAId,IACtBJ,EAAOiB,SAASC,GAAK,GACrBlB,EAAOmB,OAAOnB,EAAOiB,SAASG,EAAG,EAAGhB,EAAU,KAEhD,MACF,KAAK,EACCJ,EAAOiB,SAASG,EAAIlB,IACtBF,EAAOiB,SAASG,GAAK,GACrBpB,EAAOmB,OAAOjB,EAAU,GAAI,EAAGF,EAAOiB,SAASC,IAEjD,MACF,KAAK,EACClB,EAAOiB,SAASC,EAAId,IACtBJ,EAAOiB,SAASC,GAAK,GACrBlB,EAAOmB,OAAOnB,EAAOiB,SAASG,EAAG,EAAGhB,EAAU,KAEhD,MACF,KAAK,EACCJ,EAAOiB,SAASG,EAAIlB,IACtBF,EAAOiB,SAASG,GAAK,GACrBpB,EAAOmB,OAAOjB,EAAU,GAAI,EAAGF,EAAOiB,SAASC,IAEjD,MACF,QACEG,QAAQC,IAAI,oBAEhBtB,EAAOuB,yBAGHf,EAAe,GACjBR,EAAOwB,QAAQC,OAAWC,UAAU,IACpCjB,EAAgBD,EAAe,IACtBA,EAAe,IACxBR,EAAOwB,QAAQC,OAAWC,SAAS,IACnCjB,EAAgBD,EAAe,OAKjC,mCACEZ,IAAKC,EACL8B,KAAM,CAAC3B,EAAQC,EAAG2B,YAClBC,qBAAsB,MAKb/B,eAAiBJ,G,cC5FnBoC,EAAb,WAKI,WAAYC,GAAa,oBACrBC,KAAKC,WAAaF,EAClBC,KAAKE,KAAOC,MAAMC,MAAM,KAAM,CAAEC,OAAQN,IAAcO,IAAIC,OAAOC,KAAMD,QACvEP,KAAKS,KAAON,MAAMC,MAAM,EAAG,CAAEC,OAAQN,IAR7C,wCAWI,SAAKW,GACD,KAAOA,IAAUV,KAAKE,KAAKQ,IACvBV,KAAKE,KAAKQ,GAASV,KAAKE,KAAKF,KAAKE,KAAKQ,IACvCA,EAAQV,KAAKE,KAAKQ,GAEtB,OAAOA,IAhBf,mBAmBI,SAAMC,EAAMC,GACR,IAAMC,EAAWb,KAAKc,KAAKH,GACrBI,EAAYf,KAAKc,KAAKF,GACxBC,IAAaE,IAGjBf,KAAKC,YAAc,EACfD,KAAKS,KAAKI,GAAYb,KAAKS,KAAKM,GAChCf,KAAKE,KAAKW,GAAYE,EACff,KAAKS,KAAKI,GAAYb,KAAKS,KAAKM,GACvCf,KAAKE,KAAKa,GAAaF,GAEvBb,KAAKE,KAAKW,GAAYE,EACtBf,KAAKS,KAAKM,IAAc,QAhCpC,KCiBA,SAASC,EAAsBC,EAAMC,EAAUC,GAC7C,OAAIA,EAAYD,EAEP,CAACC,EAAYF,EAAME,GAEnB,CAACA,EAAYD,EAAW,EAAGC,EAAYD,GAI3C,SAASE,EAAmBH,EAAMI,GAOvC,IAJA,IAAMH,EAAWD,EAAOI,EAClBC,EAAY,IAAIxB,EAAUoB,GAC5BK,EAAY,GACZC,EAAW,GACNC,EAAIR,EAAMQ,EAAIP,EAAUO,IAC/BF,EAAUG,KAAKD,GAEjB,IAAK,IAAIA,EAAIP,EAAUO,EAAe,EAAXP,EAAcO,IACnCA,EAAIR,IAAS,GACfM,EAAUG,KAAKD,GAInB,IAAIE,GADJJ,EDJK,SAAsBK,GAGzB,IADA,IACSH,EADMG,EAAYvB,OACL,EAAGoB,EAAI,EAAGA,IAAK,CACjC,IAAII,EAAIC,KAAKC,MAAMD,KAAKE,UAAYP,EAAI,IACpCQ,EAAML,EAAYH,GACtBG,EAAYH,GAAKG,EAAYC,GAC7BD,EAAYC,GAAKI,EAErB,OAAOL,ECLGM,CAAaX,IACElB,OAAS,EAEpC,EAAG,CACD,IAAM8B,EAAcZ,EAAUI,GAD7B,EAE8BX,EAAsBC,EAAMC,EACvDiB,GAHH,mBAEMC,EAFN,KAEiBC,EAFjB,KAIGf,EAAUR,KAAKsB,KAAed,EAAUR,KAAKuB,GAC/Cb,EAASE,KAAKS,GAEdb,EAAUgB,MAAMF,EAAWC,GAE7BV,GAAc,QACkB,IAAzBL,EAAUrB,YACnB,KAAO0B,GAAc,GACnBH,EAASE,KAAKH,EAAUI,IACxBA,GAAc,EAKhB,IAFA,IAAMY,EAAWpC,MAAMC,MAAM,KAAM,CAACC,OAAQa,IAAWsB,MAAK,GACtDC,EAAUtC,MAAMC,MAAM,KAAM,CAACC,OAAQa,IAAWsB,MAAK,GAClDf,EAAI,EAAGA,EAAIR,EAAMQ,IACxBgB,EAAQhB,IAAK,EAEf,IAAK,IAAIA,EAAI,EAAGA,EAAIJ,EAAMI,IACxBc,EAASd,EAAIR,IAAQ,EAEvB,IAAK,IAAIQ,EAAI,EAAGA,EAAID,EAASnB,OAAQoB,IAC/BD,EAASC,GAAKP,EAChBuB,EAAQjB,EAASC,KAAM,EAEvBc,EAASf,EAASC,GAAKP,IAAY,EAGvC,MAAO,CAACqB,EAAUE,GAGpB,SAASC,EAAkBtD,EAAGF,EAAGyD,EAAOC,EAAQC,GAC9C,OACI,uBAAM5D,SAAU,CAACG,EAAIuD,EAAQ,EAAG,EAAGzD,GAAI4D,SAAU,CAAC,EAAG,EAAG,GAAxD,UACE,mCAAmBC,OAAO,WAAWpD,KAAM,CAACgD,EAAOC,EAAQC,KAC3D,qCAAqBE,OAAO,WAAWC,MAAM,cAKrD,SAASC,EAAgB7D,EAAGF,EAAGyD,EAAOC,EAAQC,GAC5C,OACI,uBAAM5D,SAAU,CAACG,EAAG,EAAGF,EAAIyD,EAAQ,GAAIG,SAAU,CAAC,EAAa,GAAVhB,KAAKoB,GAAU,GAApE,UACE,mCAAmBH,OAAO,WAAWpD,KAAM,CAACgD,EAAOC,EAAQC,KAC3D,qCAAqBE,OAAO,WAAWC,MAAM,cAM9C,SAASG,EAASlC,EAAMI,EAAMoB,EAASF,EAAUa,EAAYC,EAChEC,EAAYC,EAAWC,GAEzB,IADA,IAAMC,EAAQ,GACLhC,EAAI,EAAGA,EAAIR,EAAMQ,IACxB,IAAK,IAAII,EAAI,EAAGA,EAAIR,EAAMQ,IACpBY,EAAQhB,EAAIR,EAAOY,IACrB4B,EAAM/B,KACJgB,EAA+BjB,EAAI2B,EAAhBG,EAA6BD,EAAa,EAC1CzB,EAAIuB,EAAhBI,EAA4BJ,EAAaE,EAC1CD,EAAaC,IAEb,IAAN7B,GAAiB,IAANI,GAGXU,EAASd,EAAIR,EAAOY,IACtB4B,EAAM/B,KAAKuB,EAA6BxB,EAAI2B,EAAhBG,EACX1B,EAAIuB,EAAhBI,EAA6BF,EAAa,EAC3CF,EAAaE,EAAYD,EAAaC,IAIhD,IAAK,IAAI7B,EAAI,EAAGA,EAAIR,EAAO,EAAGQ,IAC5BgC,EAAM/B,KAAKgB,EAA+BjB,EAAI2B,EAAhBG,EAA6BD,EAAa,EACvDjC,EAAO+B,EAAnBI,EAA+BJ,EAAaE,EAAYD,EACzDC,IAEN,IAAK,IAAI7B,EAAI,EAAGA,EAAIJ,EAAMI,IACxBgC,EAAM/B,KAAKuB,EAA6BhC,EAAOmC,EAAnBG,EACX9B,EAAI2B,EAAhBI,EAA6BF,EAAa,EAAGF,EAAaE,EAC3DD,EAAaC,IAEnB,OAAOG,EC1HT,SAASC,EAAU/F,EAAOC,GAExB,IAAMqD,EAAOtD,EAAMsD,KACb0C,EAAOhG,EAAMgG,KACbP,EAAazF,EAAMyF,WACnBC,EAAc1F,EAAM0F,YACpBC,EAAa3F,EAAM2F,WACnBE,EAAY7F,EAAM6F,UAClBD,EAAY5F,EAAM4F,UARK,EAmCEzF,WAAesD,EAAmBH,EAAM0C,IAnC1C,yCAmCrBpB,EAnCqB,KAmCXE,EAnCW,OAsCK3E,WAAe,GAtCpB,mBAsCtBe,EAtCsB,KAsCXN,EAtCW,OAwCET,WAAemD,GAxCjB,mBAwCtB2C,EAxCsB,KAwCTC,EAxCS,OA0CE/F,WAAe6F,GA1CjB,mBA0CtBG,EA1CsB,KA0CTC,EA1CS,KA4CvBC,EAAclG,WAEdmG,GAAehD,EAAOmC,EAAa,EACnCc,GAAeP,EAAOP,EAAa,EAEnCzE,EAAY,kBAAQyE,EAAa,EAAIQ,EAAcR,EAAaa,GAChErF,EAAY,kBAAQwE,EAAa,EAAIU,EAAcV,EAAac,GA2CtE,OApCApG,sBAA0BF,GAAK,iBAAO,CACpCc,YAAa,WACX,IAAIyF,EAAO,EACPC,EAAO,EACX,OAAQvF,GACN,KAAK,EAAGkF,EAAQD,EAAc,GAC5BM,EAAON,EAAc,EACrB,MACF,KAAK,EAAGD,EAAQD,EAAc,GAC5BO,EAAOP,EAAc,EACrB,MAEF,KAAK,EAAGG,EAAQD,EAAc,GAC5BM,EAAON,EAAc,EAErB,MACF,KAAK,EAAGD,EAAQD,EAAc,GAC5BO,EAAOP,EAAc,EACrB,MAEF,QACEvE,QAAQC,IAAI,oBAAqBT,GAErC,OAAOmF,EAAYK,QAAQ3F,aA3BC0E,EAAa,EA2BWe,EA3BDf,EAAaa,EAC/C,SAACK,GAAD,OAAWlB,EAAa,EAAIkB,EAAMlB,EAAac,EA0BLK,CAAaH,GAAOvF,IAEjFC,SAAU,WAER,OADAP,GAAcM,EAAY,GAAK,GACxBmF,EAAYK,QAAQtF,UAAUJ,IAAaC,KAAcC,EAAY,GAAK,IAEnFE,UAAW,WAGT,OADAR,IAAeM,EAAY,GAAK,EAAI,GAAK,GAClCmF,EAAYK,QAAQvF,SAASH,IAAaC,MAAeC,EAAY,GAAK,EAAI,GAAK,QAK5F,eAAC,IAAD,CAAQb,OAAQ,CACdwG,IAAK,GAAIvF,SAAU,CAACN,IAAa,EAAGC,IAAcwE,IADpD,UAIE,cAAC,EAAD,CACExF,IAAKoG,IACP,8BAAchB,MAAM,UAAUyB,UAAW,KACzC,2BAAWA,UAAW,EAAGxF,SAAU,CAAC,IAAK,IAAK,OAE9C,iCACE+D,MAAM,UACN0B,SAAS,UACTC,YAAY,UACZF,UAAW,IAEZtB,EAASlC,EAAM0C,EAAMlB,EAASF,EAAUa,EAAYC,EAAaC,EAAYC,EAAWC,GACzF,uBAAMvE,SAAU,CAAC,GAAI,GAAI,GAAI6D,SAAU,CAAW,GAAVhB,KAAKoB,GAAU,EAAG,GAA1D,UACE,mCAAmBH,OAAO,WAAWpD,KAAM,CAAC,IAAK,IAAK,MACtD,kCAAkBoD,OAAO,WAAWC,MAAM,eAE5C,uBAAM/D,SAAU,CAAC,EAAG,GAAI,GAAI6D,SAAU,CAAW,GAAVhB,KAAKoB,GAAU,EAAG,GAAzD,UACE,mCAAmBH,OAAO,WAAWpD,KAAM,CAAC,IAAK,IAAK,MACtD,oCAAoBoD,OAAO,WAAWC,MAAM,oBAQrClF,mBAAiB4F,G,MC9HjB,SAASkB,IACtB,IAAMC,EAAS/G,WAWf,OACE,qBAAKgH,UAAU,MAAf,SACE,sBAAKA,UAAU,gBAAf,UACE,cAAC,EAAD,CACA7D,KAAQ,GACR0C,KAAQ,GACRP,WAAc,GACdC,YAAe,GACfC,WAAc,EACdE,UAAa,IACbD,UAAa,IACb3F,IAAKiH,IACL,wBAAQC,UAAU,iBAAiBC,QArBf,WACxBF,EAAOR,QAAQ3F,eAoBX,0BAGA,wBAAQoG,UAAU,mBAAmBC,QArBpB,WACrBF,EAAOR,QAAQvF,YAoBX,uBAGA,wBAAQgG,UAAU,oBAAoBC,QArBpB,WACtBF,EAAOR,QAAQtF,aAoBX,6BC7BR,IAAMiG,EAAcC,SAASC,eAAe,QAC5CC,IAASC,OAAO,cAACR,EAAD,IAASI,K","file":"static/js/main.e16fac19.chunk.js","sourcesContent":["import * as React from 'react';\nimport { extend, useThree, useFrame } from 'react-three-fiber';\nimport { TrackballControls } from 'three/examples/jsm/controls/TrackballControls';\nimport * as THREE from 'three';\n\n// extend THREE to include TrackballControls\nextend({ TrackballControls });\n\nconst Controls = (props, ref) => {\n  const controls = React.useRef();\n  const { camera, gl } = useThree();\n\n  // TODO(weijia): make these constant states or props\n  const [targetX, setTargetX] = React.useState(180);\n  const [targetZ, setTargetZ] = React.useState(180);\n  const [targetDirection, setDirection] = React.useState(0);\n  // Current angle is the remaining angle the camera needs to rotate\n  const [currentAngle, setCurrentAngle] = React.useState(0);\n\n  React.useImperativeHandle(ref, () => ({\n    moveForward: (posCoordX, posCoordY, direction) => {\n      setTargetX(posCoordX);\n      setTargetZ(posCoordY);\n      setDirection(direction);\n\n    },\n    turnLeft: (posCoordX, posCoordY, direction) => {\n      setTargetX(posCoordX);\n      setTargetZ(posCoordY);\n      setDirection(direction);\n      setCurrentAngle(90 + currentAngle);\n    },\n    turnRight: (posCoordX, posCoordY, direction) => {\n      setTargetX(posCoordX);\n      setTargetZ(posCoordY);\n      setDirection(direction);\n      setCurrentAngle(currentAngle - 90);\n    },\n  }));\n\n  useFrame(() => {\n    // update the view as the vis is interacted with\n    //controls.current.update();\n    switch (targetDirection) {\n      case 0:\n        if (camera.position.z > targetZ) {\n          camera.position.z -= 0.5;\n          camera.lookAt(camera.position.x, 0, targetZ - 10);\n        }\n        break;\n      case 3:\n        if (camera.position.x < targetX) {\n          camera.position.x += 0.5;\n          camera.lookAt(targetX + 10, 0, camera.position.z);\n        }\n        break;\n      case 2:\n        if (camera.position.z < targetZ) {\n          camera.position.z += 0.5;\n          camera.lookAt(camera.position.x, 0, targetZ + 10);\n        }\n        break;\n      case 1:\n        if (camera.position.x > targetX) {\n          camera.position.x -= 0.5;\n          camera.lookAt(targetX - 10, 0, camera.position.z);\n        }\n        break;\n      default:\n        console.log(\"direction error!\");\n      }\n    camera.updateProjectionMatrix()\n\n    //camera.lookAt(camera.position.x, 0, camera.position.z);\n    if (currentAngle > 0) {\n      camera.rotateY(THREE.Math.degToRad(-2));\n      setCurrentAngle(currentAngle - 2);\n    } else if (currentAngle < 0) {\n      camera.rotateY(THREE.Math.degToRad(2));\n      setCurrentAngle(currentAngle + 2);\n    }\n  });\n\n  return (\n    <trackballControls\n      ref={controls}\n      args={[camera, gl.domElement]}\n      dynamicDampingFactor={0.1}\n    />\n  );\n};\n\nexport default React.forwardRef(Controls);\n","export class UnionFind {\n    partsCount;\n    rank;\n    path;\n\n    constructor(elementNum) {\n        this.partsCount = elementNum;\n        this.path = Array.apply(null, { length: elementNum }).map(Number.call, Number)\n        this.rank = Array.apply(0, { length: elementNum });\n    }\n\n    find(index) {\n        while (index !== this.path[index]) {\n            this.path[index] = this.path[this.path[index]];\n            index = this.path[index];\n        }\n        return index;\n    }\n\n    union(left, right) {\n        const leftRoot = this.find(left);\n        const rightRoot = this.find(right);\n        if (leftRoot === rightRoot) {\n            return;\n        }\n        this.partsCount -= 1;\n        if (this.rank[leftRoot] < this.rank[rightRoot]) {\n            this.path[leftRoot] = rightRoot;\n        } else if (this.rank[leftRoot] > this.rank[rightRoot]) {\n            this.path[rightRoot] = leftRoot;\n        } else {\n            this.path[leftRoot] = rightRoot;\n            this.rank[rightRoot] += 1;\n        }\n    }\n}\n\nexport function shuffleArray(targetArray) {\n    // Reference: https://stackoverflow.com/questions/3943772/how-do-i-shuffle-the-characters-in-a-string-in-javascript\n    const length = targetArray.length;\n    for (let i = length - 1; i > 0; i--) {\n        let j = Math.floor(Math.random() * (i + 1));\n        let tmp = targetArray[i];\n        targetArray[i] = targetArray[j];\n        targetArray[j] = tmp;\n    }\n    return targetArray;\n}\n","import {shuffleArray, UnionFind} from \"../Utils/Utils\";\n\n// Wall global index definination example:\n// (The below two pictures are the same 3*3 maze, we separte vertical and horizontal walls to make it looks more clear)\n//   \n//   012            \n//   --- \n//   345 \n//   ---\n//   678    \n//  \n//  9|10|11|\n// 12|13|14| \n// 15|16|17|\n//     \n\n/* Given an wall index, output the neighbour cell index (In x+z*numZ format) */\nfunction getWallNeighbourCells(numX, numCells, wallIndex) {\n  if (wallIndex < numCells) {\n    // wallIndex < numCells, it is a horizontal wall\n    return [wallIndex - numX, wallIndex];\n  } else {\n    return [wallIndex - numCells - 1, wallIndex - numCells];\n  }\n}\n\nexport function initLabyrinthWalls(numX, numY) {\n  // The algorithm is:\n  // \n  const numCells = numX * numY;\n  const unionFind = new UnionFind(numCells);\n  let wallArray = [];\n  let resArray = [];\n  for (let i = numX; i < numCells; i++) {\n    wallArray.push(i);\n  }\n  for (let i = numCells; i < numCells * 2; i++) {\n    if (i % numX !== 0) {\n      wallArray.push(i);\n    }\n  }\n  wallArray = shuffleArray(wallArray);\n  let currentPos = wallArray.length - 1;\n\n  do {\n    const currentWall = wallArray[currentPos];\n    const [neighborA, neighborB] = getWallNeighbourCells(numX, numCells,\n        currentWall);\n    if (unionFind.find(neighborA) === unionFind.find(neighborB)) {\n      resArray.push(currentWall);\n    } else {\n      unionFind.union(neighborA, neighborB);\n    }\n    currentPos -= 1;\n  } while (unionFind.partsCount !== 1);\n  while (currentPos >= 0) {\n    resArray.push(wallArray[currentPos]);\n    currentPos -= 1;\n  }\n\n  const wallLeft = Array.apply(null, {length: numCells}).fill(false);\n  const wallTop = Array.apply(null, {length: numCells}).fill(false);\n  for (let i = 0; i < numX; i++) {\n    wallTop[i] = true;\n  }\n  for (let i = 0; i < numY; i++) {\n    wallLeft[i * numX] = true;\n  }\n  for (let i = 0; i < resArray.length; i++) {\n    if (resArray[i] < numCells) {\n      wallTop[resArray[i]] = true;\n    } else {\n      wallLeft[resArray[i] - numCells] = true;\n    }\n  }\n  return [wallLeft, wallTop]\n}\n\nfunction GenHorizontalWall(x, z, width, height, depth) {\n  return (\n      <mesh position={[x + width / 2, 0, z]} rotation={[0, 0, 0]}>\n        <boxBufferGeometry attach=\"geometry\" args={[width, height, depth]}/>\n        <meshLambertMaterial attach=\"material\" color=\"orange\"/>\n      </mesh>\n  );\n}\n\nfunction GenVerticalWall(x, z, width, height, depth) {\n  return (\n      <mesh position={[x, 0, z + width / 2]} rotation={[0, Math.PI * 0.5, 0]}>\n        <boxBufferGeometry attach=\"geometry\" args={[width, height, depth]}/>\n        <meshLambertMaterial attach=\"material\" color=\"orange\"/>\n      </mesh>\n  )\n\n}\n\nexport function GenWalls(numX, numY, wallTop, wallLeft, blockWidth, blockHeight,\n    blockDepth, mazeWidth, mazeDepth) {\n  const walls = []\n  for (let i = 0; i < numX; i++) {\n    for (let j = 0; j < numY; j++) {\n      if (wallTop[i + numX * j]) {\n        walls.push(\n          GenHorizontalWall(-mazeWidth + i * blockWidth - blockDepth / 2,\n                -mazeDepth + j * blockWidth, blockWidth + blockDepth,\n                blockHeight, blockDepth));\n      }\n      if (i === 0 && j === 0) {\n        continue;\n      }\n      if (wallLeft[i + numX * j]) {\n        walls.push(GenVerticalWall(-mazeWidth + i * blockWidth,\n            -mazeDepth + j * blockWidth - blockDepth / 2,\n            blockWidth + blockDepth, blockHeight, blockDepth));\n      }\n    }\n  }\n  for (let i = 0; i < numX - 1; i++) {\n    walls.push(GenHorizontalWall(-mazeWidth + i * blockWidth - blockDepth / 2,\n        -mazeDepth + numY * blockWidth, blockWidth + blockDepth, blockHeight,\n        blockDepth));\n  }\n  for (let i = 0; i < numY; i++) {\n    walls.push(GenVerticalWall(-mazeWidth + numX * blockWidth,\n        -mazeDepth + i * blockWidth - blockDepth / 2, blockWidth + blockDepth,\n        blockHeight, blockDepth));\n  }\n  return walls;\n}","import * as React from 'react';\nimport { Canvas, useFrame, useUpdate } from 'react-three-fiber'\nimport Controls from './Controls';\nimport * as THREE from \"three\";\nimport { GenWalls, initLabyrinthWalls } from './Walls';\n\nfunction Labyrinth(props, ref) {\n\n  const numX = props.numX;\n  const numZ = props.numZ;\n  const blockWidth = props.blockWidth;\n  const blockHeight = props.blockHeight;\n  const blockDepth = props.blockDepth;\n  const mazeDepth = props.mazeDepth;\n  const mazeWidth = props.mazeWidth;\n\n  // Direction definination:\n  //\n  //             top\n  //      ^\n  //      |\n  //      | z\n  //      | \n  // left | a             right\n  //      | x\n  //      | i\n  //      | s\n  //      |______________>\n  //            x axis\n  //\n  //            bottom\n\n  // WallLeft and wall top are two conceptual matrix of booleans(they are flattened to arrays for performance), recording\n  // whether a wall exist or not for a certain cell.\n  //\n  // wallTop: whether the wall on the top(in the 2D world) of a cell exists\n  // wallLeft: whether the wall on the left of a cell exists\n  // The isExist information for the wall on the right of the cell is provided by the wallLeft of the cell's right neighbour cell, so as for\n  // the bottom wall.\n  //\n  // To lookup the top wall info cell(x, y), we call wallTop[x + y*numZ]\n  const [[wallLeft, wallTop],] = React.useState(initLabyrinthWalls(numX, numZ));\n  // direction is the orientation the camera faces to.\n  // 0: Up, 1: right, 2: down, 3: left\n  const [direction, setDirection] = React.useState(0);\n  // currentPosX is the current cell index(in X axis)\n  const [currentPosX, setPosX] = React.useState(numX);\n  // currentPosZ is the current cell index(in Z axis)\n  const [currentPosZ, setPosZ] = React.useState(numZ);\n  // Handle for the controler\n  const controlsRef = React.useRef();\n  // Starting point in the x and z axis(this is coordinate, not index)\n  const startCoordX = -numX * blockWidth / 2;\n  const startCoordY = -numZ * blockWidth / 2;\n  // Get the current logical coordinate\n  const posCoordX = () => (-blockWidth / 2 + currentPosX * blockWidth + startCoordX);\n  const posCoordY = () => (-blockWidth / 2 + currentPosZ * blockWidth + startCoordY);\n  // An ugly work around to solve the invariance problem within the same call for the state update\n  // TODO(weijia): remove this work around\n  const newPosCoordX = (val) => (-blockWidth / 2 + val * blockWidth + startCoordX);\n  const newPosCoordY = (val) => (-blockWidth / 2 + val * blockWidth + startCoordY);\n\n  // TODO(weijia): Maybe combine these with the functions in Control?\n  React.useImperativeHandle(ref, () => ({\n    moveForward: () => {\n      let newX = 0;\n      let newZ = 0;\n      switch (direction) {\n        case 0: setPosZ(currentPosZ - 1);\n          newZ = currentPosZ - 1;\n          break;\n        case 1: setPosX(currentPosX - 1);\n          newX = currentPosX - 1;\n          break;\n\n        case 2: setPosZ(currentPosZ + 1);\n          newZ = currentPosZ + 1;\n\n          break;\n        case 3: setPosX(currentPosX + 1);\n          newX = currentPosX + 1;\n          break;\n\n        default:\n          console.log(\"Direction error: \", direction);\n      }\n      return controlsRef.current.moveForward(newPosCoordX(newX), newPosCoordY(newZ), direction);\n    },\n    turnLeft: () => {\n      setDirection((direction + 1) % 4);\n      return controlsRef.current.turnRight(posCoordX(), posCoordY(), (direction + 1) % 4);\n    },\n    turnRight: () => {\n      // To make the mod non-negative;\n      setDirection(((direction - 1) % 4 + 4) % 4);\n      return controlsRef.current.turnLeft(posCoordX(), posCoordY(), ((direction - 1) % 4 + 4) % 4);\n    }\n  }));\n\n  return (\n    <Canvas camera={{\n      fov: 80, position: [posCoordX(), 0, posCoordY() + blockWidth]\n    }}>\n      {/* TODO(weijia): Add params to the controls */}\n      <Controls\n        ref={controlsRef} />\n      <ambientLight color=\"#ffffff\" intensity={0.1} />\n      <spotLight intensity={1} position={[300, 300, 4000]} />\n\n      <hemisphereLight\n        color=\"#ffffff\"\n        skyColor=\"#ffffbb\"\n        groundColor=\"#080820\"\n        intensity={1.0}\n      />\n      {GenWalls(numX, numZ, wallTop, wallLeft, blockWidth, blockHeight, blockDepth, mazeWidth, mazeDepth)}\n      <mesh position={[0, -10, 0]} rotation={[Math.PI * 0.5, 0, 0]}>\n        <boxBufferGeometry attach=\"geometry\" args={[400, 400, 0.1]} />\n        <meshToonMaterial attach=\"material\" color=\"#405940\" />\n      </mesh>\n      <mesh position={[0, 10, 0]} rotation={[Math.PI * 0.5, 0, 0]}>\n        <boxBufferGeometry attach=\"geometry\" args={[400, 400, 0.1]} />\n        <meshMatcapMaterial attach=\"material\" color=\"lightblue\" />\n      </mesh>\n\n    </Canvas>\n  );\n}\n\n\nexport default React.forwardRef(Labyrinth);\n","import * as React from 'react';\nimport Labyrinth from './Labyrinth/Labyrinth';\nimport './styles.css';\n\nexport default function App() {\n  const visRef = React.useRef();\n\n  const handleMoveForward = () => {\n    visRef.current.moveForward();\n  };\n  const handleTurnLeft = () => {\n    visRef.current.turnLeft();\n  };\n  const handleTurnRight = () => {\n    visRef.current.turnRight();\n  };\n  return (\n    <div className=\"App\">\n      <div className=\"vis-container\">\n        <Labyrinth\n        numX = {10}\n        numZ = {10}\n        blockWidth = {40}\n        blockHeight = {20}\n        blockDepth = {1}\n        mazeDepth = {200}\n        mazeWidth = {200}\n        ref={visRef}/>\n        <button className=\"forward-button\" onClick={handleMoveForward}>\n          Move Forward\n        </button>\n        <button className=\"turn-left-button\" onClick={handleTurnLeft}>\n          Turn Left\n        </button>\n        <button className=\"turn-right-button\" onClick={handleTurnRight}>\n          Turn Right\n        </button>\n\n      </div>\n    </div>\n  );\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\n\nimport App from \"./App\";\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(<App />, rootElement);\n"],"sourceRoot":""}